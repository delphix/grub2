#!/bin/bash -e

merge_debconf_into_conf()
{
  local tmpfile; tmpfile="$1"
  local setting; setting="$2"
  local template; template="$3"

  db_get "$template"
  local value; value="$(echo "$RET" | sed -e 's,[$`"\@],\\&,g')"
  if grep -q "^${setting}=" "$tmpfile"; then
    sed -i -re "s@^(${setting}=).*@\1\"${value}\"@" "$tmpfile"
  else
    echo >> "$tmpfile"
    echo "${setting}=\"${value}\"" >> "$tmpfile"
  fi
}

# This only works on a Linux system with udev running.  This is probably the
# vast majority of systems where we need any of this, though, and we fall
# back reasonably gracefully if we don't have it.
cached_available_ids=
available_ids()
{
  local id path

  if [ "$cached_available_ids" ]; then
    echo "$cached_available_ids"
    return
  fi

  [ -d /dev/disk/by-id ] || return
  cached_available_ids="$(
    for path in /dev/disk/by-id/*; do
      [ -e "$path" ] || continue
      printf '%s %s\n' "$path" "$(readlink -f "$path")"
    done | sort -k2 -s -u | cut -d' ' -f1
  )"
  echo "$cached_available_ids"
}

all_disks()
{
  local id
  for id in $(available_ids); do
    case $id in
      *-part*) ;;
      *) echo "$id" ;;
    esac
  done
}

# In order to determine whether we accidentally ran grub-install without
# upgrade-from-grub-legacy on versions older than 1.98+20100617-1, we need
# to be able to scan a disk to determine whether GRUB 2 was installed in its
# boot sector.  This is specific to i386-pc (but that's the only platform
# where we need it).
scan_grub2()
{
  if ! dd if="$1" bs=512 count=1 2>/dev/null | grep -aq GRUB; then
    # No version of GRUB is installed.
    return 1
  fi

  # The GRUB boot sector always starts with a JMP instruction.
  initial_jmp="$(dd if="$1" bs=2 count=1 2>/dev/null | od -Ax -tx1 | \
                 head -n1 | cut -d' ' -f2,3)"
  [ "$initial_jmp" ] || return 1
  initial_jmp_opcode="${initial_jmp%% *}"
  [ "$initial_jmp_opcode" = eb ] || return 1
  initial_jmp_operand="${initial_jmp#* }"
  case $initial_jmp_operand in
    47|4b|4c|63)
      # I believe this covers all versions of GRUB 2 up to the package
      # version where we gained a more explicit mechanism.  GRUB Legacy
      # always had 48 here.
      return 0
    ;;
  esac

  return 1
}

case "$1" in
  configure)
    . /usr/share/debconf/confmodule

    case @PACKAGE@ in
      grub-pc)

        if grep -q "[= ]/sbin/update-grub" /etc/kernel-img.conf 2> /dev/null ; then
          echo -e "\n/etc/kernel-img.conf still contains /sbin/update-grub in the hooks." >&2
          echo -e "Running sed over it to remove the /sbin/ prefix.\n" >&2
          sed -i /etc/kernel-img.conf -e "s,\(.*\)  */sbin/update-grub$,\1 update-grub,g"
        fi
        mkdir -p /boot/grub

        if test -e /boot/grub/device.map && ! test -e /boot/grub/core.img ; then
          # Looks like your device.map was generated by GRUB Legacy, which
          # used to generate broken device.map (see #422851).  Avoid the risk
          # by regenerating it.
          grub-mkdevicemap --no-floppy
        fi
      ;;
    esac

    tmp_default_grub="$(mktemp "/tmp/grub.XXXXXXXXXX")"
    trap "rm -f ${tmp_default_grub}" EXIT
    cp -p /usr/share/grub/default/grub ${tmp_default_grub}

    merge_debconf_into_conf "$tmp_default_grub" GRUB_CMDLINE_LINUX grub2/linux_cmdline
    merge_debconf_into_conf "$tmp_default_grub" GRUB_CMDLINE_LINUX_DEFAULT grub2/linux_cmdline_default

    ucf --three-way --debconf-ok --sum-file=/usr/share/grub/default/grub.md5sum ${tmp_default_grub} /etc/default/grub
    package="$(ucfq --with-colons /etc/default/grub | cut -d : -f 2)"
    if echo $package | grep -q "^grub-" ; then
      ucfr --force @PACKAGE@ /etc/default/grub
    else
      ucfr @PACKAGE@ /etc/default/grub
    fi

    case @PACKAGE@ in
      grub-pc)

        fix_mixed_system=
        if test -e /boot/grub/stage2 && test -e /boot/grub/menu.lst && \
           ! test -e /boot/grub/grub2-installed && \
           test -z "$UPGRADE_FROM_GRUB_LEGACY"; then
          # Unfortunately, it's still possible that the user upgraded fully
          # to GRUB 2 in some way other than running
          # upgrade-from-grub-legacy; perhaps they ran grub-install by hand
          # for some reason.  It's really quite difficult to detect this
          # situation, because the only difference between this and a
          # working chainloaded setup is that in this case grub-setup has
          # been run.  So, to try to tell the difference, we scan the boot
          # sectors of all disks for a GRUB 2 boot sector.  Hopefully this
          # won't cause too much to explode, since I can't think of a better
          # method.
          grub2_disks=
          for disk in $(all_disks); do
            if scan_grub2 "$disk"; then
              grub2_disks="${grub2_disks:+$grub2_disks }$(readlink -f "$disk")"
            fi
          done
          if [ "$grub2_disks" ]; then
            # No || true here; it's vital that the user sees this, and it's
            # better to throw an error than to do the wrong thing.
            db_subst grub-pc/mixed_legacy_and_grub2 DISKS "$grub2_disks"
            db_input critical grub-pc/mixed_legacy_and_grub2
            db_go
            db_get grub-pc/mixed_legacy_and_grub2
            if [ "$RET" = true ]; then
              db_reset grub-pc/install_devices
              UPGRADE_FROM_GRUB_LEGACY=1
              fix_mixed_system=1
              # Fall through to normal installation logic.
            fi
          fi
        fi

        if test -e /boot/grub/stage2 && test -e /boot/grub/menu.lst && \
           ! test -e /boot/grub/grub2-installed && \
           test -z "$UPGRADE_FROM_GRUB_LEGACY"; then
          db_get grub-pc/chainload_from_menu.lst
          if $RET ; then
            # Create core.img (but do not risk writing to MBR).
            # Using grub-probe instead of "(hd0)" avoids (UUID=) hack slowness
            # in case /boot/grub is not on (hd0) in device.map.
            echo "Generating core.img" >&2
            grub-install --no-floppy --grub-setup=/bin/true "$(grub-probe -t drive /boot/grub)" > /dev/null

            # Update menu.lst to reflect that:
            # - core.img is present now
            # - core.img has to be the first option
            echo "Saving menu.lst backup in /boot/grub/menu.lst_backup_by_grub2_postinst" >&2
            cp /boot/grub/menu.lst{,_backup_by_grub2_postinst}
            echo "Running update-grub Legacy to hook our core.img in it" >&2
            LET_US_TRY_GRUB_2=true /usr/lib/grub-legacy/update-grub 2>&1 | sed -e "s/^/    /g" >&2
            # We just hooked GRUB 2 in menu.lst; then also generate grub.cfg.
            touch /boot/grub/grub.cfg
          fi
        else
          while :; do
            db_subst grub-pc/install_devices CHOICES `grub-mkdevicemap -m - | sed -e "/^(fd[0-9]\+)/d;s,.*\t,,g" | tr '\n' ',' | sed -e 's/,$//g;s/,/, /g'`
            db_input high grub-pc/install_devices || true
            db_go
            db_get grub-pc/install_devices
            for i in `echo $RET | sed -e 's/,/ /g'` ; do
              if grub-install --force --no-floppy $i ; then
                # We just installed GRUB 2; then also generate grub.cfg.
                touch /boot/grub/grub.cfg
              fi
            done

            db_get grub-pc/install_devices
            if [ "$RET" ]; then
              break
            fi

            # Reset the seen flag if the current answer is false, since
            # otherwise we'll loop with no indication of why.
            db_get grub-pc/install_devices_empty
            if [ "$RET" = false ]; then
              db_fset grub-pc/install_devices_empty seen false
            fi
            if db_input critical grub-pc/install_devices_empty; then
              db_go
              db_get grub-pc/install_devices_empty
              if [ "$RET" = true ]; then
                break
              else
                db_fset grub-pc/install_devices seen false
                db_fset grub-pc/install_devices_empty seen false
                # Go back round the loop.
              fi
            else
              break # noninteractive
            fi
          done
        fi

        # /boot/grub/ has more chances of being accessible by GRUB
        if test -e /boot/grub/grub.cfg ; then
          for i in /usr/share/grub/unicode.pf2 /usr/share/images/desktop-base/moreblue-orbit-grub.png ; do
            if test -e $i ; then
              cp $i /boot/grub/
            fi
          done
        fi

        if [ "$fix_mixed_system" ]; then
          # These never contain any valuable information, and they aren't
          # useful for boot any more, since we just overwrote MBR/PBR.
          rm -f /boot/grub/{{xfs,reiserfs,e2fs,fat,jfs,minix}_stage1_5,stage{1,2}}
          # Remove marker file used to indicate that grub-install was run
          # rather than upgrade-from-grub-legacy.  Since stage2 has been
          # removed, we don't need this any more.
          rm -f /boot/grub/grub2-installed
        fi
      ;;
    esac

    # If grub.cfg has been generated, update it.
    if test -e /boot/grub/grub.cfg ; then
      update-grub 3>&-
    fi
  ;;
  abort-upgrade|abort-remove|abort-deconfigure)
  ;;
  *)
    echo "postinst called with unknown argument \`$1'" >&2
    exit 1
  ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
